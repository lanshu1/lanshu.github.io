{"pages":[{"title":"404","text":"","link":"/404.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"links","text":"","link":"/links/index.html"}],"posts":[{"title":"Antd的Select如何设置对内容能够筛选 （不是value）","text":"Select组件是按照筛选项的value来筛选的，而我们需要的是按照筛选项的显示的内容来筛选, 这时候该如何设置呢。optionFilterProp=”children” 1234567891011121314151617181920&lt;a-form-item :colon=\"false\" label=\"入职公司\"&gt; &lt;a-select allowClear showSearch // 是否支持搜索 optionFilterProp=\"children\" // *把搜索的value换成children placeholder=\"请选择\" size=\"small\" :labelInValue=\"true\" v-decorator=\"['companyCode',{rules: [{ required: true, message: '请选择入职公司!' }]}]\" &gt; &lt;a-select-option :key=\"index\" :value=\"item.code\" v-for=\"(item, index) in branchAndArea\" &gt;{{item.name}}&lt;/a-select-option&gt; &lt;/a-select&gt;&lt;/a-form-item&gt;","link":"/post/2d396c73.html"},{"title":"form表单label标签for导致点击文字触发输入框解决方案","text":"123456789101112131415161718192021222324252627282930&lt;a-form-item :label=\"label+'图片'\" :label-col=\"{ span: 2 }\" :wrapper-col=\"{ span: 22 }\" id=\"picture\" // 只需加个与校验(roomPicture)不同名的id即可&gt;&lt;a-upload :action=\"'/platformApi/file/uploadFile'\" :beforeUpload=\"beforeUpload\" :data=\"dataObj\" :disabled=\"type==='check'\" :headers=\"headers\" :showUploadList=\"false\" @change=\"handleChange($event,'place')\" listType=\"picture-card\" name=\"multipartFile\" v-decorator=\"['roomPicture',{rules: [{ required: true, message: '请选择房间图片' }]}]\"&gt; &lt;img :src=\"imageUrlForPlace\" alt=\"avatar\" style=\"max-width:400px;\" v-if=\"imageUrlForPlace\" /&gt; &lt;div v-else&gt; &lt;a-icon :type=\"loadingForImgForPlace ? 'loading' : 'plus'\" /&gt; &lt;div class=\"ant-upload-text\"&gt;Upload&lt;/div&gt; &lt;/div&gt;&lt;/a-upload&gt;&lt;/a-form-item&gt;","link":"/post/2abc5415.html"},{"title":"antd-vue中给table表格整行加点击事件","text":"1234567891011121314&lt;a-table :columns=\"columns\" :dataSource=\"data\" :loading=\"loading\" :pagination=\"pagination\" :rowKey=\"record =&gt; record.id\" @change=\"paginationChange\" bordered :customRow=\"click\" // 这个是重点，主要是给table添加属性的作用&gt; // 内容&lt;/a-table&gt; 1234567891011methods: { click(record, index){ return { on: { click: () =&gt; { console.log(record,index) } } } }}","link":"/post/3b94f69c.html"},{"title":"antd中的form表单initialValue导致数据不更新问题","text":"前言初步理解 ： initialValue就是所谓的defaultValue,只会在第一次赋值的时候改变，却又有一些不同，因为 initialValue又会因其他改动而改变。 然而当获取的数据重新上来要渲染的时候 ，initialValue的值却又不改变，所以 让人觉得很是捉摸不透。 解决： 1this.props.form.resetFields(); 例：如果第一步操作执行的是修改操作，一些默认值填充上去，如果不作处理，第二部执行新增操作的时候，会把第一个默认的值带着，导致新增弹框弹出来的时候form表单中就是数值，效果体验特别不好， 后面发现在Modal文件里面添加componentWillReceiveProps中处理报表重置，就可以刷新form表单 12345componentWillReceiveProps(nextProps) { if (!nextProps.modal.modalUpdateDetail) { this.props.form.resetFields(); }} 后来还是会在同样的坑里面跳 但这回不是在Modal里的Form,而是在类似TAB组件切换数据的时候，this.state的内容变了，但是render的initialValue还是保留着原来的数据 解决方法 1 我第一想到的是强制刷新，window.location.reload() 但这样的办法并不是理想的效果 2 治根还得治本，我知道是initialValue的问题 但如果参考原来的在componentWillReceiveProps里面重置表单数据，会出现其他各种问题，因为 componentWillReceiveProps 这个函数你可能因为别的原因触发了 12345componentWillReceiveProps(nextProps) { if (!nextProps.modal.modalUpdateDetail) { this.props.form.resetFields(); }} 后来想着，既然是因为initialValue已经有了初始化，那在切换操作的时候，将它清除掉好了，所以在离开的操作函数里添加了 this.props.form.resetFields();","link":"/post/7a7df4a6.html"},{"title":"数组常用方法","text":"扩展运算符1234567891011121314151617181920212223let arr = [1, 2, 3];let arr2 = [...arr]; //等同于 let arr2 = Array.from(arr);let [a, b, c] = [1, 2, 3]; //a=1, b=2, c=3let [ , , third] = [\"foo\", \"bar\", \"baz\"]; //third=\"baz\"let [head, ...tail] = [1, 2, 3, 4]; //head=1, tail=234let [x, y, ...z] = ['a']; //x=a, y=undefined, z=[], 如果解构不成功,变量的值就等于undefinedlet [x, y = 'b'] = ['a']; // x='a', y='b',解构赋值允许指定默// 解构赋值超强const { form: { validateFields }} = this; validateFields((err, values) =&gt; { if (!err) { // eslint-disable-next-line no-console console.log(\"Received values of form: \", values); } }); Array.from：把类数组（获取一组元素、arguments…）对象转成数组，个人观点：具备length这个东西都可以使用Array.from()转数组123456789101112131415161718192021let aLi = document.querySelectorAll('ul li');let arrLi = Array.from(aLi); //等同于let arrLi = [].slice.call(aLi); ES5方法function show(){ let args = Array.from(arguments); console.log(args) //[1,2,3,4,5]}show(1,2,3,4,5)let str = 'strive';let arr = Array.from(str); //等同于let arr = str.split('');console.log(arr); //[s,t,r,i,v,e]let json = { 0:'apple', 1:'banana', 2:'orange', length:3}let arr = Array.from(json);console.log(arr); //['apple','banana','orange']，json对象必须有length，否则为[] Array.of：把一组值，转成数组（没用过）12let arr = Array.of('apple','banana','orange');console.log(arr); //['apple','banana','orange'] Array.find：查找，找出第一个符合条件的数组成员，如果没找到返回undefined12345let arr = [23,900,101,80,100];let res = arr.find((val, index, arr) =&gt; { return val&gt;100;})console.log(res); //返回数字900 Array.findIndex：找的是位置，没找到返回-112345let arr = [23,900,101,80,100];let res = arr.findIndex((val, index, arr) =&gt; { return val&gt;100;})console.log(res); //返回数字1 Array.fill：Array.fill(填充的东西,开始位置,结束位置)（没用过）12345let arr = new Array(10);arr.fill('默认值');console.log(arr); //['默认值'......]10个默认值arr.fill('默认值',1,3); //1起始位置，3结束位置console.log(arr); //下标为1和下标为2的是默认值，其他为空 Array.includes：返回布尔值true/false，跟indexOf类似123let arr = ['apple','banana','orange'];let b = arr.includes('banana');console.log(b); //返回布尔值true","link":"/post/c58dd91c.html"},{"title":"javascript中new url()属性，轻松解析url地址","text":"1.首先写一个假的地址（q=URLUtils.searchParams&amp;topic=api）相当于当前的window.location.href 1234567891011const urlParams = new URL(window.location.href);urlParams.searchParams.has(\"topic\") === true; // trueurlParams.searchParams.get(\"topic\") === \"api\"; // trueurlParams.searchParams.getAll(\"topic\"); // [\"api\"]urlParams.searchParams.get(\"foo\") === \"\"; // trueurlParams.searchParams.append(\"topic\", \"webdev\");urlParams.searchParams.toString(); // \"q=URLUtils.searchParams&amp;topic=api&amp;topic=webdev\"urlParams.searchParams.set(\"topic\", \"More webdev\");urlParams.searchParams.toString(); // \"q=URLUtils.searchParams&amp;topic=More+webdev\"urlParams.searchParams.delete(\"topic\");urlParams.searchParams.toString(); // \"q=URLUtils.searchParams\"","link":"/post/6519afef.html"},{"title":"数组迭代","text":"数组法代是一件很重要的操作，在 ECMAScript 5 之前主要使用 for 语句实现，这种方式不是很方便， 为此 ECMAScript 5 新增了 5 个与迭代相关的方法。 1.forEach：为数组中的每个元素调用定义的回调函数。 2.every：检查定义的回调函数如果每一项都返回true，则返回 true。 3.some：检查定义的回调函数如果任意一项返回true。返回 true。 4.map：对数组的每个元素调用定义的回调函数，并返回包含结果的数组。 5.filter：对数组的每个元素调用定义的回调函数，并返回回调函数为其返回 true 的值的数组。 具体说明如下。 forEach12345678910111213//forEach中可选参数thisArg可以为函数指定this指向，忽略则指向window。（箭头函数无效，仅普通函数）let thisArg = { name: '熊猫', age: 21, sex: '女'}let arr = [1, 2, 3];arr.forEach(function(value, index, array){ console.log(this) //{name: '熊猫', age: 21, sex: '女'} console.log(value) //123 console.log(index) //012 console.log(array) //1,2,3},thisArg); every1234let arr = [1, 2, 3];console.log(arr.every(function(value, index, array){ return value &gt; 2;})) //false some1234let arr = [1,2,3]; console.log(arr.some(function(value, index, array){ return value &gt; 2;})) //true map12345let arr = [1, 2, 3];arr = arr.map(function(value, index, array){ return value + 1;});console.log(arr); //2,3,4 filter12345var arr = [5, \"element\", 10, \"the\", true];var result = arr.filter(function(value, index, array){ return (typeof value === 'string');});document.write(result); //返回值：[\"element\", \"the\"]","link":"/post/2cb76261.html"},{"title":"call/apply/bind","text":"使用 call() 和 apply()call 和 apply是 Function 对象的原型方法，它们能够将特定函数当作一个方法绑定到指定对象上并进行调用。具体用法如下： 12function.call(thisobj, args... ) function.apply(thisobj, args) 其中参数 thisobj 表示this指定的对象，参数 args 表示要传递给被调用函数的参数。 call()方法只能接收多个参数列表， 而 apply()只能接收一个数组或者伪类数组，数组元素将作为参数传递给被调用的函数。 1234567891011121314151617181920//定义一个add 方法 function add(x, y) { return x + y; } //用call 来调用 add 方法 function myAddCall(x, y) { //调用 add 方法 的 call 方法 return add.call(this, x, y); } //apply 来调用 add 方法 function myAddApply(x, y) { //调用 add 方法 的 applly 方法 return add.apply(this, [x, y]); } console.log(myAddCall(10, 20)); //输出结果30 console.log(myAddApply(20, 20)); //输出结果40 使用 bind()用来把函数绑定到指定对象上。 1function.bind(thisArg [, arg1[, arg2 [, argN]]]) function：必需参数， 一个函数对象。 2.thisArg：必需参数，this关键字可在新函数中引用的对象。 3.arg1[, arg2[, argN]]：可选参数，要传递到新函数的参数的列表。 1234567891011var checkNumericRange = function (value) { if (typeof value !== 'number'){ return false; }else{ return value &gt;= this.minimum &amp;&amp; value &lt;= this.maximum; }}var range = { minimum: 10, maximum: 20 };var boundCheckNumericRange = checkNumericRange.bind(range); var result = boundCheckNumericRange (12); document.write (result); //true","link":"/post/5e4b6aaf.html"},{"title":"使用 arguments 对象","text":"arguments 对象表示参数集合，它是一个伪类数组，拥有与数组相似的结构，可以通过数组下标的形式访问函数实参值，但是没有基础 Array 的原型方法 1234567//函数没有定义形参，但是在函数体内通过 arguments 对象可以获取传递给该函数的每个实参值。 function f () { //定义没有形参的函数 for(var i = 0; i &lt; arguments.length; i++ ) { //循环读取函数的 arguments 对象 alert(arguments[i]); //显示指定下标的实参的值 }}f(3, 3, 6); //逐个显示每个传递的实参 12345678通过修改arguments对象的 length属性值，也可以达到改变函数实参个数的目的。当 length 属性值增大时，则增加的实参值为 undefined，如果 length 属性值减小，则会丢弃arguments 数据集合后面对应个数的元素。 function f(){ arguments.length = 2 //修改 arguments 对象的 length 属性值 for(var i = 0; i &lt; arguments.length; i++ ) { alert(arguments[i]); }}f(3, 3, 6); //返回提示 3、 3 使用 callee 回调函数arguments 对象包含一个 callee 属性，它引用当前 arguments 对象所属的函数，使用该属性可以在函数体内调用函数自身（arguments.callee()）。在匿名函数中，callee 属性比较有用，利用它可以设计函数选代操作。 1234567891011//使用 arguments.callee 获取匿名函数，然后通过函数的 length 属性获取函数形参个数，最后比较实参与形参个数以检测用户传递的参数是否符合要求。 function f (x, y, z) { var a = arguments.length; //获取函数实参的个数 var b =arguments.callee.length; //获取函数形参的个数 if (a != b) { //如果形参和实参个数不相等，则提示错误信息 throw new Error(\"传递的参数不匹配\"); } else { //／如果形参和实参数目相同，则返回它们的和 return x + y + z; }}alert(f(3, 4, 5)); //返回值为 12","link":"/post/f238c019.html"},{"title":"while/do while","text":"while语句while 语句是基本的重复操作语句。 在while语句中会先计算循环条件，如果循环条件返回值为 false，则会跳出循环结构，如果循环条件返回值为 true，则执行循环体内的语句，如果一直为true则导致死循环。 12345var n = 0; //声明并初始化循环变量 while (n &lt; 10) { //循环条件 n ++; //递增循环变量 alert (n); //执行循环操作} do/while 语句do/while 语句是 while 循环结构的特殊形式，只不过它把循环条件放在结构的底部，而不是 while 语句顶部。其语法格式如下： 123456var n = 0; //声明并初始化循环变量do { //执行循环体命令 n++; alert(n);}while(n &lt; 10);//循环条件","link":"/post/19e4da19.html"},{"title":"js字符串数组['1','2','3']转number","text":"12let arr = ['1','2','3'];arr.split(',').map(Number);","link":"/post/5ed73dad.html"},{"title":"reduce/reduceRight","text":"使用 reduce 和 reduceRight 方法可以汇总数组元素的值，具体用法如下： reduce123456function appendCurrent (previousValue, currentValue) { return previousValue + \"::\" + currentValue;}var elements = [\"abc\", \"def\", 123, 456];var result = elements.reduce(appendCurrent);document.write(result); //abc::def::123::456 reduceRight123456function appendCurrent (previousValue, currentValue) { return previousValue + \"::\" + currentValue;}var elements = [\"abc\", \"def\", 123, 456];var result = elements.reduceRight(appendCurrent);document.write(result); //456::123::def::abc","link":"/post/dce9f18b.html"},{"title":"检测类型","text":"JavaScript 是弱类型语言，对类型没有严格限制，但是在程序中经常需要对类型进行检测和转换，下面结合示例介绍类型检测和转换的技巧。 使用 typeof 检测类型typeof 运算符专门用来测试值的类型，特别对于原始值有效，而对于对象类型的数据，如数组、对象等，返回的值都是字符串”object”。 123456789101112131415alert( typeof 1); //返回字符串\"number\" alert( typeof \"a\"); //返回字符串\"string\"alert( typeof true); //返回字符串\"boolean\" alert( typeof {}); //返回字符串\"object\" alert( typeof [] ); //返回字符串\"object\"alert( typeof function(){});//返回字符串\"function\" alert( typeof undefined); //返回字符串\"undefined\" alert( typeof null); //返回字符串\"object\" alert( typeof NaN); //返回字符串\"number\"//由于 null 值返回类型为 object，用户可以定义一个检测简单数据类型的一般方法。function type(o) { return (o === null ) ? \"null\" : (typeof o); //如果是 null 值，则返回字符串\"null\"，否则返回(typeof o)表达式的值} 使用 constructor 检测类型对于对象、数组等复杂数据，可以使用 Object 对象的 constructor 属性进行检测。 constructor 表示构造器，该属性值引用的是构造当前对象的函数。 1234var o = {}; var a = []; alert( o.constructor == Object); //返回 true alert( a.constructor == Array); //返回 true 使用 constructor 属性可以检测绝大部分数据的类型，但对于 undefined 和 null 特殊值， 就不能够使用 constructor 属性，否则会抛出异常。这时可以先把值转换为布尔值，如果为 true，则说明是存在值的， 然后再调用 constructor 属性。 封装类型检测方法： toString()使用 toString() 方法可以设计一种更安全的检测 JavaScript 数据类型的方法，用户还可以根据开发需 要进一步补充检测类型的范围。 由 Object 对象定义的 toString() 方法返回的字符串形式是[object class]，其中object是大类表示对象的通用类型，class是小类表示对象的内部类型（Array,Function,Date,Math,Error……），用户自定义对象为object，class 值提供的信息与对象的 constructor 属性值相似，但是 class 值是以字符串的形式提供这些信息的，这在特定的环境中是非常有用的。如果使用 typeof运算符来检测，则所有对象的 class 值都为“Object” 或“Function”。所以不能够提供有效信息。 但是，要获取对象的 class 值的唯一方法是必须调用 Object 的原型方法 toString()，因为很多类型对象都会重置 Object 的 toString() 方法，所以不能直接调用对象的 toString() 方法。 12345var d = new Date(); alert(d.toString()); //返回当前 UTC 时间字符串 var m = Object.prototype.toString; alert(m.apply(d)); //返回字符串\"[object Date]\" 123456789101112131415161718192021//安全检测 JavaScript 基本数据类型和内置对象 //参数： o表示检测的值 //返回值：返回字符串\"undefined\"、 \"number\"、\"boolean\"、\"string\"、 \"function\"、 \"regexp\"、\"array\"、\"date\"、\"error\"、\"object\"或\"null\"function typeOf (o) { var _toString = Object.prototype.toString; //获取对象的 toString （）方法引用 //列举基本数据类型和内置对象类型，你还可以进一步补充该数组的检测数据类型范围 var _type = { \"undefined\":\"undefined\", \"number\":\"number\", \"boolean\":\"boolean\", \"string\":\"string\", \"[object Function]\":\"function\", \"[object RegExp]\":\"regexp\", \"[object Array]\":\"array\", \"[object Date]\":\"date\", \"[object Error)\":\"error\" } return _type[typeof o] || _type[_toString.call(o)) || (o ? \"object\" : \"null\"); //通过把值转换为字符串，然后匹配返回字符串中是否包含特定字符进行检测}","link":"/post/3a82717f.html"},{"title":"javascript错误类型","text":"ECMA-262 定义了下列 7 种错误类型，简单说明如下： Error：普通异常。通常与 throw 语句和 try／catch 语句一起使用。 利用属性 name 可以声明或了 解异常的类型，利用 message 属性可以设置和读取异常的详细信息。 EvalError： 在不正确使用 eval（）方法时抛出。 SyntaxError：抛出语法错误。 RangeError：在数字超出合法范围时抛出。 ReferenceError：在读取不存在的变量时抛出 。 TypeError：当一个值的类型错误时抛出该异常。 URLError：由 URL 的编码和解码方法抛出。 其中 Error 是基类，其他错误类型都继承自该类型。因此，所有错误类型共享了一组相同的属性， 错误对象中的方法全是默认的对象方法。 Error 类型的错误很少见，如果有也是浏览器抛出的，这个基类 型的主要目的是供开发人员抛出自定义错误。 EvalError 类型的错误会在使用 eval（）函数发生异常时被抛出。 123//如果没有把 eval（）当成函数调用，就会抛出该类型错误。new eval(); //抛出 EvalErroreval=foo; //抛出 EvalError RangeError 类型的错误会在数值超出相应范围时触发。 JavaScript 中经常会出现这种范围错误。 123//在定义数组时，如果指定了数组不支持的项数，如－20 或 Number.MAX VALUE，就会 触发这种错误。var itemsl = new Array(-20); //抛出RangeErrorvar itemsl = new Array (Number.MAX_VALUE); //抛出RangeError 在找不到对象的情况下，会发生 ReferenceError。 12//在访问不存在的变量时，就会发生这种错误。var obj = x; //在 x 并未声明的情况下抛出 ReferenceError SyntaxError 表示语法类型错误， 当把语法错误的 JavaScript 字符串传入 eval（）函数时，就会导致此类错误。 1eval (\"a ++ b\") //抛出 SyntaxError Type Error类型在 JavaScript 中会经常用到，在变量中保存着意外的类型时，或者在访问不存在的方法时，都会导致这种错误。错误的原因虽然多种多样，但归根结底还是由于在执行特定类型的操作时， 变量的类型并不符合要求所致。 1234//最常发生类型错误的情况，就是传递给函数的参数事先未经检查，结果传入类型与预期类型不相符。 var o = new 10; //抛出 TypeError alert (\"name\" in true); //抛出 TypeError Function.prototype.toString.call (’name ’); //抛出 TypeError 在使用 encodeURL（）或 decodeURL（）时，如果 URL 格式不正确，就会导致 URIError 错误。这种错误也很少见，因为这两个函数的容错性非常高。","link":"/post/4e3a5907.html"},{"title":"js中点击返回顶部","text":"123handleScrollTop(){ window.scrollTo(0, 0); }","link":"/post/c788412.html"},{"title":"拓展 Array 方法","text":"为 Array 对象扩展了一个迭代器之后，就可以利用这个法代器进一步拓展 Array 的方法，使其能够完成更多的实用功能。 12345678910111213141516171819202122232425262728Array.prototype.each = function( f ) { //数组法代器，扩展 Array 原型方法 try{ //异常处理，避免因为不可预测的错误导致系统崩溃 this.i || ( this. i = 0 ); //定义临时变量，用来作为法代计数器 if( this.length &gt; 0 &amp;&amp; f.constructor == Function ) { //如果数组长度大于 0并且参数为函数 while( this.i &lt; this.length ) { //遍历数组 var e = this[this.i]; //获取当前元素 if( e &amp;&amp; e.constructor == Array ) { //如果元素存在，且为数组 e.each ( f ) ; //递归调用法代器 }else{ //否则，在元素上调用参数函数，并把元素值传递给函数 f.apply(e, [e]); } this.i++; //递加计数器 } this.i = null; //如果通历完毕，则清空计数器 } } catch(err){ //捕捉以后 } return this; //返回当前数组}//调用该迭代器var a = [1, [2, [3, 4]]];var f = function( x ) { alert(x);}a.each(f); //调用迭代器，为每个元素执行一次函数传递","link":"/post/67ac9da7.html"},{"title":"javascript中new url()属性，轻松解析url地址","text":"首先写一个假的地址（q=URLUtils.searchParams&amp;topic=api）相当于当前的window.location.href1234567891011const urlParams = new URL(window.location.href);urlParams.searchParams.has(\"topic\") === true; // trueurlParams.searchParams.get(\"topic\") === \"api\"; // trueurlParams.searchParams.getAll(\"topic\"); // [\"api\"]urlParams.searchParams.get(\"foo\") === \"\"; // trueurlParams.searchParams.append(\"topic\", \"webdev\");urlParams.searchParams.toString(); // \"q=URLUtils.searchParams&amp;topic=api&amp;topic=webdev\"urlParams.searchParams.set(\"topic\", \"More webdev\");urlParams.searchParams.toString(); // \"q=URLUtils.searchParams&amp;topic=More+webdev\"urlParams.searchParams.delete(\"topic\");urlParams.searchParams.toString(); // \"q=URLUtils.searchParams\"","link":"/post/3571313a.html"},{"title":"使用 try-catch","text":"ECMA-262 第 3 版引入了 try-catch 语旬，当 try-catch 语句中发生错误时， 浏览器会认为错误已经被处理了 ，因而不会报告错误。对于那些不要求用户懂技术，也不需要用户理解错误的 Web 应用程序，这应该说是个理想的结果。不过try-catch 能够让我们实现自己的错误处理机制。使用 try-catch 最适合处理那些无法控制的错误。假设在使用一个大型 JavaScript 库中的函数，该函 数可能会有意无意地抛出一些错误，由于我们不能修改这个库的源代码，所以大可将对该函数的调用放在try-catch语句当中，万一有什么错误发生，也好恰当地处理它们。 在明明白白地知道自己的代码会发生错误时，再使用try-catch语句就不太合适了。例如，如果传递给函数的参数是字符串而非数值，就会造成函数出错，那么就应该先检查参数的类型，然后再决定如何去做。在这种情况下，不应使用try-catch语句。作为 JavaScript 处理异常的一种标准方式。基本语法如下： 12345try { //可能会导致错误的代码 } catch(error) { //在错误发生时怎么处理} 用户应把所有可能会抛出错误的代码都放在 try 语句块中，而把那些用于错误处理的代码放在 catch 块中。 12345try { a+b; } catch (error) { alert (\"非法的变量\");} 如果 try 块中的任何代码发生了错误，就会立即退出代码执行过程，然后接着执行 catch 块。此时， catch 块会接收到一个包含错误信息的对象。与在其他语言中不同的是，即使不使用这个错误对象，也要给它起个名字。错误对象中包含的实际信息会因浏览器而异，但都有一个保存着错误消息的 message 属性。 ECMA-262 还规定了一个保存错误类型的 name 属性，当前所有浏览器都支持这个属性（Opera 9 之前的版本不支持这个属性〉。因此，在发生错误时，就可以像下面这样实事求是地显示浏览器给出的消息。 1234567//这个例子在向用户显示错误消息时，使用了错误对象的 message和name 属性。try { a+b; } catch (error) { alert(error.message); //错误信息 alert(error.name); //错误类型} 使用 finallyfinally 子旬在 try-catch 语句中是可选的，但如果 finally 子句已经使用， 则其代码无论如何都会执行。 无论try或 catch 语句块中包含什么代码一一甚至 return 语句，都不会阻止 finally 子句的执行。只要代码中包含 finally 子旬，那么无论try还是 catch 语句块中的 return 语句都将被忽略。 因此，在使用 finally 子句之前，一定要非常清楚想让代码怎么样。看下面这个函数。 12345678910//如果提供 finally 子句，则 catch 子句就成了可选的，IE7 及更早版本中有一个bug： 除非有 catch 子句，否则 finally 中的代码永远不会执行。如果考虑兼容 IE 早期版本，应提供一个 catch 子句，哪怕里面什么都不写， IE8 修复 了这个 bug。function test() { try{ return 2; } catch (error) { return l; } finally { return 0; }} 这个函数在位 try-catch 语句的每一部分都放了一条 return 语句。表面上看，调用这个函数会返回 2, 因为返回 2 的 return 语句位于try语句块中，而执行该语句又不会出错。可是，由于最后还有一个 finally 子句，结果就会导致该 return 语句被忽略， 也就是说，调用这个函数只能返回 0。 如果把自finally子句去掉，这个函数将返回 2。 使用 throw与问 try-catch 语句相配的还有一个 throw 操作符，用于随时抛出自定义错误。抛出错误时，必须要给 throw 操作符指定一个值，这个值是什么类型没有要求。 在遇到由 throw 操作符时，代码会立即停止执行。 仅当有 try-catch 语句捕获到被抛出的值时，代码才会继续执行。 12345//下列代码都是有效的。throw 1; throw \"hi\";throw true;throw {name: \"js\"}; 通过使用某种内置错误类型，可以更真实地模拟浏览器错误。每种错误类型的构造函数接收一个参数，即实际的错误消息。 1234567throw new Error (\"抛出错误\");throw new SyntaxError(\"SyntaxError\");throw new TypeError(\"TypeError\");throw new RangeError(\"RangeError\");throw new EvalError(\"EvalError\");throw new URLError(\"URLError\");throw new ReferenceError(\"ReferenceError\"); 123456789101112function process(values) { if (!(values instanceof Array)) { throw new Error(\"process()：参数必须为数组。\"); } values.sort(); for (var i=0, len=values.length; i&lt;len; i++) { if (values[i] &gt; 100) { return values[i]; } } return -1;} 错误事件任何没有通过句 try-catch 处理的错误都会触发 window 对象的 error 事件。这个事件是浏览器最早支持的事件之一IE、 Firefox 和 Chrome 为保持向后兼容，并没有对这个事件作任何修改， Opera 和 Safari 不支持 error 事件。 在任何 Web 浏览器中， onerror 事件处理程序都不会创建 event 对象，但它可以接收 3 个参数 123456window.onerror = function(message,url,line){ alert(message); //错误信息 alert(url); //错误地址 alert(line); //错误行号 return false; //在事件处理程序中返回 false，可以阻止浏览器报告错误的默认行为。} 通过返回 false，这个函数实际上就充当了整个文档中的 try-catch 语旬，可以捕获所有无代码处理的运行时错误。这个事件处理程序是避免浏览器报告错误的最后一道防线，理想情况下，只要可能就不应该使用它。只要能够适当地使用 try-catch 语句，就不会有错误交给浏览器，也就不会触发 error 事件。","link":"/post/5d2f66fe.html"},{"title":"react中异步组件以及withRouter的使用","text":"什么是异步组件？简单来说就是异步加载一个组件，正常情况浏览器加载的是我们打包好的bundle.js文件，那么这个文件是集合了所有js是代码，然而我们首屏加载并不需要一次性加载所有的组件，这会造成性能的损耗，所以我们可以使用异步组件，推荐使用（react-loadable）https://github.com/jamiebuilds/react-loadable，那么使用react-loadable就会造成路由跳转的问题，所以我们需要使用withRouter来解决，withRouter组件的功能是让当前组件有能力获取到所有的参数和内容 1234567891011121314//首先要下载yarn add react-loadable//loadable.js文件import React from 'react';import Loadable from 'react-loadable';const LoadableComponent = Loadable({ loader: () =&gt; import('./'), //./需要异步的组件 loading(){ return &lt;div&gt;正在加载&lt;/div&gt; //可以加载一些好看的loading }});export default () =&gt; &lt;LoadableComponent/&gt;; 123456789101112131415161718192021222324252627282930313233//index.js文件import React, { Component } from 'react';import { withRouter } from 'react-router-dom';import { connect } from 'react-redux';class Detail extends Component{ render(){ console.log(this.props.match.params.id); //这时候就可以获取到了，页面也不会报错了 return(&lt;div&gt;&lt;/div&gt;); }}export default connect(mapState, mapDispatch)(withRouter(Detail));//路由部分import React, { Component } from 'react';import { BrowserRouter, Route } from 'react-router-dom';import { Provider } from 'react-redux';import store from './store';import Detail from './pages/detail/loadable.js';class App extends Component{ render(){ return( &lt;Provider store={store}&gt; &lt;BrowserRouter&gt; &lt;div&gt; &lt;Route path='/detail/:id' exact component={Detail}&gt;&lt;/Route&gt; &lt;/div&gt; &lt;/BrowserRouter&gt; &lt;/Provider&gt; ); }}","link":"/post/ec468c1e.html"},{"title":"react将HTML字符串解析为HTML标签","text":"当后台返回的数据是字符串html的话，我们可以利用dangerouslySetInnerHTML属性来把字符串转换成html标签 1234function showhtml(htmlString){ var html = {__html:htmlString}; return &lt;div dangerouslySetInnerHTML={html}&gt;&lt;/div&gt; ;}","link":"/post/1decbe10.html"},{"title":"react中使用charles实现本地数据mock","text":"首先下载charles软件地址，更详细的使用方法都包含在操作文档里，包含汉化版补丁（下载后查看） 链接：https://pan.baidu.com/s/1Q5rMbcX0Wus7AwdGUWa-Wg 提取码：mkgt 如何利用charles来mock呢？首先我们要新建一个json文件来写我们的json数据1.点击菜单栏中的工具 2.点击本地映射 3.勾选启用本地映射 4.点击添加 5.协议(http) =&gt; 主机(localhost) =&gt; 端口(当前本地端口号) =&gt; 路径(/api/lala) =&gt; 点击选择，选择自己创建的json文件 =&gt; 点击确定 6.ajax请求/api/lala接口，就可以返回数据了 大家学会了吗？","link":"/post/a56332ac.html"},{"title":"react中自定义antd主题与支持less（第二部）","text":"自定义主题首先自定义主题需要修改antd，antd本身也是less写的之后编译成css的，所以当我们需要使用less。 1.yarn add react-app-rewire-less –dev 1234567891011const { injectBabelPlugin } = require('react-app-rewired');+ const rewireLess = require('react-app-rewire-less'); module.exports = function override(config, env) {- config = injectBabelPlugin(['import', { libraryName: 'antd', style: 'css' }], config);+ config = injectBabelPlugin(['import', { libraryName: 'antd', style: true }], config);+ config = rewireLess.withLoaderOptions({+ modifyVars: { \"@primary-color\": \"#1DA57A\" },+ })(config, env); return config; }; 参考链接：https://ant.design/docs/react/use-with-create-react-app-cn 使用less如果已经配置react-app-rewire-less，则无需再进行此操作 1.npm install less-loader less –save-dev 2.修改node_modules/react_script/config下的webpack.config.dev.js 和 webpack.config-prod.js 配置文件 test: /.css$/ 改为 /.(css|less)$/ test: /.css$/ 的 use 数组配置增加 less-loader 1234567891011121314151617181920212223242526272829303132333435{ test: /\\.(css|less)$/, use: [ require.resolve('style-loader'), { loader: require.resolve('css-loader'), options: { importLoaders: 1, }, }, { loader: require.resolve('postcss-loader'), options: { // Necessary for external CSS imports to work // https://github.com/facebookincubator/create-react-app/issues/2677 ident: 'postcss', plugins: () =&gt; [ require('postcss-flexbugs-fixes'), autoprefixer({ browsers: [ '&gt;1%', 'last 4 versions', 'Firefox ESR', 'not ie &lt; 9', // React doesn't support IE8 anyway ], flexbox: 'no-2009', }), ], }, }, { loader: require.resolve('less-loader') // compiles Less to CSS } ],},","link":"/post/15c9b8d0.html"},{"title":"react调试工具Reactdevelopertools","text":"1.首先具备翻墙条件 2.进入谷歌浏览器找到扩展程序 3.搜索react，第一个就是Reactdevelopertools 4.点击安装，完成 使用如下：","link":"/post/c8b5cf9d.html"},{"title":"react中antd+css Module一起使用","text":"antd 和 css modules 不能混用,针对antd的css 单独写一条loader的规则,不开启 css modules。使用 exclude 和 include 配置参考https://segmentfault.com/q/1010000011223900,修改webpack.config.dev.js 和 webpack.config-prod.js 配置文件 (尽量不要使用less-loader 来处理css文件，在与antd一起使用时可能出现错误，单独写一条规则)，所以我们只能两个来处理css的loader。 在react中使用antd+less+css modules参考https://www.jianshu.com/p/51ff1c8be301 12345678910111213141516171819202122232425262728293031323334// ant的按需加载 { test: /\\.css$/, include: /node_modules/, use: [ require.resolve('style-loader'), { loader: require.resolve('css-loader'), options: { importLoaders: 1, }, }, { loader: require.resolve('postcss-loader'), options: { // Necessary for external CSS imports to work // https://github.com/facebookincubator/create-react-app/issues/2677 ident: 'postcss', plugins: () =&gt; [ require('postcss-flexbugs-fixes'), autoprefixer({ browsers: [ '&gt;1%', 'last 4 versions', 'Firefox ESR', 'not ie &lt; 9', // React doesn't support IE8 anyway ], flexbox: 'no-2009', }), ], }, }, ], }, 12345678910111213141516171819202122232425262728293031323334353637// 正常的网页中的css { test: /\\.css$/, exclude: /node_modules/, use: [ require.resolve('style-loader'), { loader: require.resolve('css-loader'), options: { importLoaders: 1, modules: true, localIdentName: \"[name]__[local]___[hash:base64:5]\", }, }, { loader: require.resolve('postcss-loader'), options: { // Necessary for external CSS imports to work // https://github.com/facebookincubator/create-react-app/issues/2677 ident: 'postcss', plugins: () =&gt; [ require('postcss-flexbugs-fixes'), autoprefixer({ browsers: [ '&gt;1%', 'last 4 versions', 'Firefox ESR', 'not ie &lt; 9', // React doesn't support IE8 anyway ], flexbox: 'no-2009', }), ], }, }, ], },","link":"/post/b9ba1266.html"},{"title":"react中prop-types的使用","text":"什么是prop-types？prop代表父组件传递过来的值，types代表类型。简单来说就是用来校验父组件传递过来值的类型 1234import PropTypes from 'prop-types';TodoItem.propTypes = { test: PropTypes.string.isRequired, //加上isRequired以后，即使父组件没传递值也会抛出警告} 12345import PropTypes from 'prop-types';TodoItem.propTypes = { test: PropTypes.arrayOf(PropTypes.string, PropTypes.number) //可以设置多个类型 test: PropTypes.oneOfType([PropTypes.string, PropTypes.number]) //符合任意一个类型即可} 那么如何解决父组件没传递值也会抛出的警告呢？可以使用react里的defaultProps来设置默认的props值 123TodoItem.defaultProps = { test: 'hello word' } 还有想学习更多proptypes的同学请关注react文档https://reactjs.org/docs/typechecking-with-proptypes.html 大家学会了吗？","link":"/post/94fda07a.html"},{"title":"react组件性能优化PureComponent","text":"首先我们使用react组件会配合connect来连接store获取state，那么只要store中的state发生改变组件就会重新渲染，所以性能不高，一般我们可以使用shouldComponentUpdate()来判断，但react提供了PureComponent组件，当我们把Component替换成PureComponent的时候会自动帮我们优化组件避免不必要的渲染，注意：前提是使用immutable来管理数据，不然会出现一些问题。 1234567import React, { PureComponent } from 'react';class App extends PureComponent{ render(){ return(&lt;div&gt;&lt;/div&gt;); }}export default App;","link":"/post/52660866.html"},{"title":"react中state与setstate的使用","text":"我们可以利用state来定义一些变量的初始值 1234//放在construcor里this.state = { list: [1, 2, 3]} 要更改state里的值，注意要遵循react里immutable规范，state不允许我们做任何改变，只能通过setState来更改 123const list = [...this.state.list];list.splice(0, 1);this.setState({list:list}); 强烈推荐setstate的写法如下： 12345const list = [...this.state.list];list.splice(0, 1);this.setState((prevState) =&gt; ({ //外面加小括号可以代替return list: list})); 还可以这样写 12345this.setState((prevState) =&gt; { //外面加小括号可以代替return const list = [...prevState.list]; list.splice(0, 1); return {list}}); setState第二个参数回调函数，在setState设置完之后执行，可以对改变后的数据进行操作 1234567this.setState((prevState) =&gt; { //外面加小括号可以代替return const list = [...prevState.list]; list.splice(0, 1); return {list}}, () =&gt; { console.log(this.state.list);});","link":"/post/9f19373f.html"},{"title":"create-react-app 构建的项目使用代理 proxy","text":"1.首先进入项目运行 npm run eject 展开详细代码（只可以使用一次，展开后不可恢复） 2.create-react-app 的版本在低于 2.0 的时候可以在 package.json 增加 proxy 配置， 配置成如下： 123456\"proxy\":{ \"/api/**\":{ \"target\":\"https://easy-mock.com/mock/5c0f31837214cf627b8d43f0/\", //需要代理的地址 \"changeOrigin\": true }} 3.create-react-app 的版本高于 2.0 版本的时候在 package.json 只能配置 string 类型， 配置成如下： 1\"proxy\": \"https://easy-mock.com/mock/5c0f31837214cf627b8d43f0/\", 4.更好的配置，建立 src/setupProxy.js 文件，npm 安装 install http-proxy-middleware , 配置成如下：(可配置多个代理) 123456789101112131415const proxy = require(\"http-proxy-middleware\");module.exports = function(app) { app.use( proxy(\"/base/\", { target: \"http://45.32.15.21:8090/\", changeOrigin: true }) ); app.use( proxy(\"/api/\", { target: \"https://easy-mock.com/mock/5c0f31837214cf627b8d43f0/\", changeOrigin: true }) );};","link":"/post/1c181ff4.html"},{"title":"antd递归渲染左侧菜单","text":"123456789101112renderMenu = (data) =&gt; { return data.map((item) =&gt; { if(item.children){ return ( &lt;SubMenu title={item.title} key={item.key}&gt; { this.renderMenu(item.children) } &lt;/SubMenu&gt; ) } return &lt;Menu.Item title={item.title} key={item.key}&gt;{item.title}&lt;Menu.Item&gt; })}","link":"/post/d8d10588.html"},{"title":"react中label标签的作用","text":"当我们点击输入内容触发input焦点的时候，就需要使用到label标签里的htmlFor属性来扩大点击的区域 代码如下：","link":"/post/b1e1930a.html"},{"title":"react中使用immutable","text":"官方文档（https://immutable-js.github.io/immutable-js/docs/#/） 有人说 Immutable 可以给 React 应用带来数十倍的提升，也有人说 Immutable 的引入是近期 JavaScript 中伟大的发明，因为同期 React 太火，它的光芒被掩盖了。这些至少说明 Immutable 是很有价值的，下面我们来一探究竟。 JavaScript 中的对象一般是可变的（Mutable），因为使用了引用赋值，新的对象简单的引用了原始对象，改变新的对象将影响到原始对象。如 foo={a: 1}; bar=foo; bar.a=2 你会发现此时 foo.a 也被改成了 2。虽然这样做可以节约内存，但当应用复杂后，这就造成了非常大的隐患，Mutable 带来的优点变得得不偿失。为了解决这个问题，一般的做法是使用 shallowCopy（浅拷贝）或 deepCopy（深拷贝）来避免被修改，但这样做造成了 CPU 和内存的浪费。 Immutable 可以很好地解决这些问题。 什么是 IMMUTABLE DATAImmutable Data 就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象。Immutable 实现的原理是 Persistent Data Structure（持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗，Immutable 使用了 Structural Sharing（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。 immutable提供了get和set方法","link":"/post/bc84495a.html"},{"title":"react中使用antd按需加载（第一部）","text":"什么是react按需加载？简单来说就是当我们引用antd的时候需要引入全局css样式，这会对性能造成一定的影响，那么使用按需加载以后就不需要引入css全局样式了，直接引入功能模块即可，既然需要设置按需加载就要对webpack文件进行修改，需要我们执行npm run eject命令来展开项目的隐藏文件，如果只是简单的修改，我们可以使用react-app-rewired定义全局变量，react-app-rewired的作用就是在不eject的情况下,覆盖create-react-app的配置。具体如下： 使用 react-app-rewired 对 create-react-app 的默认配置进行自定义1.yarn add react-app-rewired –dev 123456789/* package.json */\"scripts\": {- \"start\": \"react-scripts start\",+ \"start\": \"react-app-rewired start\",- \"build\": \"react-scripts build\",+ \"build\": \"react-app-rewired build\",- \"test\": \"react-scripts test --env=jsdom\",+ \"test\": \"react-app-rewired test --env=jsdom\",} 2.然后在项目根目录创建一个config-overrides.js用于修改默认配置 1234module.exports = function override(config, env) { // do stuff with the webpack config... return config;}; 使用babel-plugin-importbabel-plugin-import 是一个用于按需加载组件代码和样式babel 插件（原理），现在我们尝试安装它并修改config-overrides.js 文件 1.yarn add babel-plugin-import –dev 123456+ const { injectBabelPlugin } = require('react-app-rewired'); module.exports = function override(config, env) {+ config = injectBabelPlugin(['import', { libraryName: 'antd', libraryDirectory: 'es', style: 'css' }], config); return config; }; 或者也可以修改 12345678910111213141516{ test: /\\.(js|jsx|mjs)$/, include: paths.appSrc, loader: require.resolve('babel-loader'), options: { plugins: [ // 引入样式为 'css' // style为true 则默认引入less ['import', { libraryName: 'antd', style: true }], ], // This is a feature of `babel-loader` for webpack (not Babel itself). // It enables caching results in ./node_modules/.cache/babel-loader/ // directory for faster rebuilds. cacheDirectory: true, },}, 参考链接：https://ant.design/docs/react/use-with-create-react-app-cn","link":"/post/e1aaa582.html"},{"title":"react子组件向父组件传值","text":"子组件向父组件传值，注意父组件传递函数的时候必须绑定this到当前父组件（handleEmail={this.handleEmail.bind(this)}），不然会报错 1234567891011121314151617181920212223242526272829303132333435363738394041/***实现在输入框输入邮箱时，在div中即时显示输入内容***/&lt;body&gt; &lt;div id=\"test\"&gt;&lt;/div&gt;&lt;/body&gt;//子组件var Child = React.createClass({ render: function(){ return ( &lt;div&gt; 邮箱：&lt;input onChange={this.props.handleEmail}/&gt; &lt;/div&gt; ) }});//父组件var Parent = React.createClass({ getInitialState: function(){ return { email: '' } }, handleEmail: function(event){ this.setState({email: event.target.value}); }, render: function(){ return ( &lt;div&gt; &lt;div&gt;邮箱：{this.state.email}&lt;/div&gt; &lt;Child name=\"email\" handleEmail={this.handleEmail.bind(this)}/&gt; &lt;/div&gt; ) }});React.render( &lt;Parent /&gt;, document.getElementById('test'));","link":"/post/22835517.html"},{"title":"react中ref的使用","text":"在react中获取真实dom的时候就需要用到ref属性，具体使用如下 123456789101112131415161718var MyComponent = React.createClass({ handleClick: function() { console.log(this.input) }, render: function() { return ( &lt;div&gt; &lt;input type=\"text\" ref={(input) =&gt; {this.input = input}} /&gt; &lt;input type=\"button\" value=\"Focus the text input\" onClick={this.handleClick} /&gt; &lt;/div&gt; ); }});ReactDOM.render( &lt;MyComponent /&gt;, document.getElementById('example'));","link":"/post/9d55fbbd.html"},{"title":"创建react开发环境","text":"准备工作1.下载node.js http://nodejs.cn/download/ 推荐下载长期支持的版本 2.下载cnpm https://jingyan.baidu.com/article/9080802239521cfd90c80f55.html 开始生成项目环境1.运行 cnpm install -g create-react-app 2.create-react-app todolist（文件名） 3.cd todolist（进入项目文件） 4.npm run start（启动项目）","link":"/post/968d7123.html"},{"title":"react中虚拟DOM","text":"简单来说虚拟DOM就是一个js对象，相对于真实dom来做比较更节约性能，虚拟DOM执行过程如下","link":"/post/1bd06a42.html"},{"title":"react中create-react-app配置antd按需加载（方法二）","text":"1.yarn add babel-plugin-import 2.在根目录下的package.json下的bable中添加相应代码 12345678910111213141516\"babel\": { \"presets\": [ \"react-app\" ], \"plugins\": [ [ \"import\", { \"libraryName\": \"antd\", \"style\": \"css\" // 引入样式为 css // style为true 则默认引入less } ] ] } 3.重启项目yarn run start","link":"/post/cc896a6d.html"},{"title":"react中关于create-react-app2里css相关配置","text":"先看 webpack.config.dev.js 里的相关代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// style files regexesconst cssRegex = /\\.css$/;const cssModuleRegex = /\\.module\\.css$/;const sassRegex = /\\.(scss|sass)$/;const sassModuleRegex = /\\.module\\.(scss|sass)$/; // common function to get style loadersconst getStyleLoaders = (cssOptions, preProcessor) =&gt; { const loaders = [ require.resolve('style-loader'), { loader: require.resolve('css-loader'), options: cssOptions, }, { // Options for PostCSS as we reference these options twice // Adds vendor prefixing based on your specified browser support in // package.json loader: require.resolve('postcss-loader'), options: { // Necessary for external CSS imports to work // https://github.com/facebook/create-react-app/issues/2677 ident: 'postcss', plugins: () =&gt; [ require('postcss-flexbugs-fixes'), require('postcss-preset-env')({ autoprefixer: { flexbox: 'no-2009', }, stage: 3, }), ], }, }, ]; if (preProcessor) { loaders.push(require.resolve(preProcessor)); } return loaders;}; module.exports = { mode: 'development',// ... module: {// ... { oneOf: [// ... { test: cssRegex, exclude: cssModuleRegex, use: getStyleLoaders({ importLoaders: 1, }), }, // Adds support for CSS Modules (https://github.com/css-modules/css-modules) // using the extension .module.css { test: cssModuleRegex, use: getStyleLoaders({ importLoaders: 1, modules: true, getLocalIdent: getCSSModuleLocalIdent, }), }, // Opt-in support for SASS (using .scss or .sass extensions). // Chains the sass-loader with the css-loader and the style-loader // to immediately apply all styles to the DOM. // By default we support SASS Modules with the // extensions .module.scss or .module.sass { test: sassRegex, exclude: sassModuleRegex, use: getStyleLoaders({ importLoaders: 2 }, 'sass-loader'), }, // Adds support for CSS Modules, but using SASS // using the extension .module.scss or .module.sass { test: sassModuleRegex, use: getStyleLoaders( { importLoaders: 2, modules: true, getLocalIdent: getCSSModuleLocalIdent, }, 'sass-loader' ), }// ...}； 4 个 样式文件后缀的正则表示，这份配置里是将普通 (s)css 文件和 (s)css module 文件是按文件名后缀不同而区分对待的，前者视为普通 css 文件，而处理后者时开启 css-loader 的 module 模式。这样做的一个好处是区分明确，全局的 class 样式加写到 .(s)css 文件里，需要加 hash 的局部样式就写到 .module.(s)css 文件里，这样也可以不用在想要写一个全局样式时把 class 包到 :global() 里了。 getStyleLoaders 是一个返回 loader 配置的函数，内部默认有 [‘style-loader’, ‘css-loader’, ‘postcss-loader’] 三个 loader。函数接受两个参数，其中第一个是 css-loader 的 option 配置。第二个是视需要添加 sass-loader 或者 less-loader。需要添加 postcss 插件，可以在 getStyleLoaders 里对应的 plugin 配置里加。以上就是 development 下关于样式的配置，下面看看 production 里不一样的地方： 12345678// style-loader 换成了下面的内容 { loader: MiniCssExtractPlugin.loader, options: Object.assign( {}, shouldUseRelativeAssetPaths ? { publicPath: '../../' } : undefined ), }, 此外配置里还多了 mini-css-extract-plugin、optimize-css-assets-webpack-plugin、postcss-safe-parser 这三个东西，第一个的作用是将构建后的 css 样式，生成 .css 文件，然后以 link 标签的形式插入到模板 html 中；第二个和第三个的作用是压缩 css 文件。","link":"/post/b377091f.html"},{"title":"typeScript基础","text":"定义变量限制类型123456789let isDone: boolean = false;let decLiteral: number = 6let sentence: string = `Hello, my name is ${myName}`let myFavoriteNumber: any = 'seven'; // 如果是 any 类型，则允许被赋值为任意类型let myFavoriteNumber: string | number; // 联合类型（Union Types）表示取值可以为多种类型中的一种let fibonacci: number[] = [1, 1, 2, 3, 5]; // 最简单的方法是使用「类型 + 方括号」来表示数组let fibonacci: (number | string)[] = [1, '1', 2, 3, 5]; // 添加多个类型let fibonacci: Array&lt;number&gt; = [1, 1, 2, 3, 5]; // 数组泛型let list: any[] = ['xcatliu', 25, { website: 'http://xcatliu.com' }]; // 一个比较常见的做法是，用 any 表示数组中允许出现任意类型 注意：使用构造函数 Boolean 创造的对象不是布尔值： 123let createdByNewBoolean: boolean = new Boolean(1);// Type 'Boolean' is not assignable to type 'boolean'.// 'boolean' is a primitive, but 'Boolean' is a wrapper object. Prefer using 'boolean' when possible. 空值JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数： 123function alertName(): void { alert('My name is Tom');} 声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null： 1let unusable: void = undefined; 对象类型–接口在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型。 1234567891011// 在定义的变量比接口少了一些属性或多一些属性是不允许的，赋值的时候，变量的形状必须和接口的形状保持一致。interface Person { name: string; age: number;}let tom: Person = { name: 'Tom'};// index.ts(6,5): error TS2322: Type '{ name: string; }' is not assignable to type 'Person'.// Property 'age' is missing in type '{ name: string; }'. 可选属性有时我们希望不要完全匹配一个形状，那么可以用可选属性： 12345678interface Person { name: string; age?: number;}let tom: Person = { name: 'Tom'}; 任意属性有时候我们希望一个接口允许有任意的属性，可以使用如下方式： 1234567891011121314151617181920212223242526272829interface Person { name: string; age?: number; [propName: string]: any;}let tom: Person = { name: 'Tom', gender: 'male'};// 需要注意的是，一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集：// 任意属性的值允许是 string，但是可选属性 age 的值却是 number，number 不是 string 的子属性，所以报错了interface Person { name: string; age?: number; [propName: string]: string;}let tom: Person = { name: 'Tom', age: 25, gender: 'male'};// index.ts(3,5): error TS2411: Property 'age' of type 'number' is not assignable to string index type 'string'.// index.ts(7,5): error TS2322: Type '{ [x: string]: string | number; name: string; age: number; gender: string; }' is not assignable to type 'Person'.// Index signatures are incompatible.// Type 'string | number' is not assignable to type 'string'.// Type 'number' is not assignable to type 'string'. 只读属性有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 readonly 定义只读属性： 123456789101112131415interface Person { readonly id: number; name: string; age?: number; [propName: string]: any;}let tom: Person = { id: 89757, name: 'Tom', gender: 'male'};tom.id = 9527;// index.ts(14,5): error TS2540: Cannot assign to 'id' because it is a constant or a read-only property. 数组类型–接口虽然接口也可以用来描述数组，但是我们一般不会这么做，因为这种方式比前两种方式复杂多了。不过有一种情况例外，那就是它常用来表示类数组。 12345// NumberArray 表示：只要索引的类型是数字时，那么值的类型必须是数字。interface NumberArray { [index: number]: number;}let fibonacci: NumberArray = [1, 1, 2, 3, 5]; 类数组123function sum() { let args: IArguments = arguments;} 其中 IArguments 是 TypeScript 中定义好了的类型，它实际上就是： 12345interface IArguments { [index: number]: any; length: number; callee: Function;} 函数声明一个函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单： 123456789function sum(x: number, y: number): number { return x + y;}let mySum = function (x: number, y: number): number { return x + y;};let tomcat = buildName('Tom', 'Cat');let tom = buildName('Tom'); 可选参数与接口中的可选属性类似，我们用 ? 表示可选的参数 1234567function buildName(firstName: string, lastName?: string) { if (lastName) { return firstName + ' ' + lastName; } else { return firstName; }} 参数默认值12345function buildName(firstName: string, lastName: string = 'Cat') { return firstName + ' ' + lastName;}let tomcat = buildName('Tom', 'Cat');let tom = buildName('Tom'); 定义函数的形状–接口我们也可以使用接口的方式来定义一个函数需要符合的形状： 12345678interface SearchFunc { (source: string, subString: string): boolean;}let mySearch: SearchFunc;mySearch = function(source: string, subString: string) { return source.search(subString) !== -1;} 类型断言类型断言（Type Assertion）可以用来手动指定一个值的类型。 有时候，我们确实需要在还不确定类型的时候就访问其中一个类型的属性或方法，比如： 1234567891011function getLength(something: string | number): number { if (something.length) { return something.length; } else { return something.toString().length; }}// index.ts(2,19): error TS2339: Property 'length' does not exist on type 'string | number'.// Property 'length' does not exist on type 'number'.// index.ts(3,26): error TS2339: Property 'length' does not exist on type 'string | number'.// Property 'length' does not exist on type 'number'. 上例中，获取 something.length 的时候会报错。 此时可以使用类型断言，将 something 断言成 string： 1234567function getLength(something: string | number): number { if ((&lt;string&gt;something).length) { return (&lt;string&gt;something).length; } else { return something.toString().length; }} 注意：类型断言不是类型转换，断言成一个联合类型中不存在的类型是不允许的 内置对象我们可以在 TypeScript 中将变量定义为这些类型 123456789let b: Boolean = new Boolean(1);let e: Error = new Error('Error occurred');let d: Date = new Date();let r: RegExp = /[a-z]/;let body: HTMLElement = document.body;let allDiv: NodeList = document.querySelectorAll('div');document.addEventListener('click', function(e: MouseEvent) { // Do something}); 安装typeScript的npm包1npm install @types/node --save-dev","link":"/post/48765c6b.html"},{"title":"typeScript理论","text":"什么是类型推论以下代码虽然没有指定类型，但是会在编译的时候报错： 123let myFavoriteNumber = 'seven';myFavoriteNumber = 7;// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'. 事实上，它等价于： 123let myFavoriteNumber: string = 'seven';myFavoriteNumber = 7;// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'. TypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。 如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查： 123let myFavoriteNumber;myFavoriteNumber = 'seven';myFavoriteNumber = 7; 访问联合类型的属性或方法当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法 1234567891011// length 不是 string 和 number 的共有属性，所以会报错。function getLength(something: string | number): number { return something.length;}// index.ts(2,22): error TS2339: Property 'length' does not exist on type 'string | number'.// Property 'length' does not exist on type 'number'.// 访问 string 和 number 的共有属性是没问题的：function getString(something: string | number): string { return something.toString();}","link":"/post/23d050fc.html"},{"title":"react中Fragment组件","text":"什么是Fragment？在我们定义组件的时候return里最外层包裹的div往往不想渲染到页面，那么就要用到我们的Fragment组件了，具体使用如下： 123456789101112131415import React, { Component, Fragment } from 'react';class TodoList extends Component { render(){ return( &lt;Fragment&gt; &lt;div&gt;&lt;input /&gt;&lt;button&gt;提交&lt;/button&gt;&lt;/div&gt; &lt;ul&gt; &lt;li&gt;学习react&lt;li/&gt; &lt;li&gt;Learning React&lt;/li&gt; &lt;/ul&gt; &lt;Fragment/&gt; ) }}export default TodoList","link":"/post/b8e6111e.html"},{"title":"typeScript进阶","text":"类型别名类型别名用来给一个类型起个新名字 12345678910type Name = string;type NameResolver = () =&gt; string;type NameOrResolver = Name | NameResolver;function getName(n: NameOrResolver): Name { if (typeof n === 'string') { return n; } else { return n(); }} 字符串字面量类型字符串字面量类型用来约束取值只能是某几个字符串中的一个 1234567type EventNames = 'click' | 'scroll' | 'mousemove';function handleEvent(ele: Element, event: EventNames) { // do something}handleEvent(document.getElementById('hello'), 'scroll'); // 没问题handleEvent(document.getElementById('world'), 'dbclick'); // 报错，event 不能为 'dbclick'// index.ts(7,47): error TS2345: Argument of type '\"dbclick\"' is not assignable to parameter of type 'EventNames'. 元组数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象 123456789101112131415161718192021222324let tom: [string, number] = ['Tom', 25];let tom: [string, number];tom[0] = 'Tom';tom[1] = 25;tom[0].slice(1);tom[1].toFixed(2);let tom: [string, number];tom[0] = 'Tom';let tom: [string, number];tom = ['Tom', 25];let tom: [string, number];tom = ['Tom'];// Property '1' is missing in type '[string]' but required in type '[string, number]'.let tom: [string, number];tom = ['Tom', 25];tom.push('male');tom.push(true);// Argument of type 'true' is not assignable to parameter of type 'string | number'. 类TypeScript 可以使用三种访问修饰符（Access Modifiers），分别是 public、private 和 protected public 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的 private 修饰的属性或方法是私有的，不能在声明它的类的外部访问 protected 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的 123456789101112131415161718192021222324252627282930313233343536373839404142// name 被设置为了 public，所以直接访问实例的 name 属性是允许的class Animal { public name; public constructor(name) { this.name = name; }}let a = new Animal('Jack');console.log(a.name); // Jacka.name = 'Tom';console.log(a.name); // Tom// 很多时候，我们希望有的属性是无法直接存取的，这时候就可以用 private 了class Animal { private name; public constructor(name) { this.name = name; }}let a = new Animal('Jack');console.log(a.name); // Jacka.name = 'Tom';// index.ts(9,13): error TS2341: Property 'name' is private and only accessible within class 'Animal'.// index.ts(10,1): error TS2341: Property 'name' is private and only accessible within class 'Animal'.// 使用 private 修饰的属性或方法，在子类中也是不允许访问的，而如果是用 protected 修饰，则允许在子类中访问class Animal { protected name; public constructor(name) { this.name = name; }}class Cat extends Animal { constructor(name) { super(name); console.log(this.name); }} readonly只读属性关键字，只允许出现在属性声明或索引签名中 123456789101112class Animal { readonly name; public constructor(name) { this.name = name; }}let a = new Animal('Jack');console.log(a.name); // Jacka.name = 'Tom';// index.ts(10,3): TS2540: Cannot assign to 'name' because it is a read-only property. 注意：如果 readonly 和其他访问修饰符同时存在的话，需要写在其后面 类的类型给类加上 TypeScript 的类型很简单，与接口类似 123456789101112class Animal { name: string; constructor(name: string) { this.name = name; } sayHi(): string { return `My name is ${this.name}`; }}let a: Animal = new Animal('Jack');console.log(a.sayHi()); // My name is Jack 类与接口1234567891011121314151617181920interface Alarm { alert();}interface Light { lightOn(); lightOff();}class Car implements Alarm, Light { alert() { console.log('Car alert'); } lightOn() { console.log('Car light on'); } lightOff() { console.log('Car light off'); }} 接口继承接口12345678interface Alarm { alert();}interface LightableAlarm extends Alarm { lightOn(); lightOff();} 接口继承类12345678910class Point { x: number; y: number;}interface Point3d extends Point { z: number;}let point3d: Point3d = {x: 1, y: 2, z: 3}; 泛型我们在函数名后添加了 ，其中 T 用来指代任意输入的类型，在后面的输入 value: T 和输出 Array 中即可使用了。接着在调用的时候，可以指定它具体的类型为 string。当然，也可以不手动指定，而让类型推论自动推算出来 123456789function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; { let result: T[] = []; for (let i = 0; i &lt; length; i++) { result[i] = value; } return result;}createArray&lt;string&gt;(3, 'x'); // ['x', 'x', 'x'] 多个类型参数定义泛型的时候，可以一次定义多个类型参数 12345function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] { return [tuple[1], tuple[0]];}swap([7, 'seven']); // ['seven', 7] 泛型约束我们可以对泛型进行约束，只允许这个函数传入那些包含 length 属性的变量 12345678interface Lengthwise { length: number;}function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T { console.log(arg.length); return arg;} 泛型接口可以使用含有泛型的接口来定义函数的形状 12345678910111213141516interface CreateArrayFunc&lt;T&gt; { (length: number, value: T): Array&lt;T&gt;;}let createArray: CreateArrayFunc&lt;any&gt;;createArray = function&lt;T&gt;(length: number, value: T): Array&lt;T&gt; { let result: T[] = []; for (let i = 0; i &lt; length; i++) { result[i] = value; } return result;}createArray(3, 'x'); // ['x', 'x', 'x']createArray(3, 'x'); // ['x', 'x', 'x'] 泛型类与泛型接口类似，泛型也可以用于类的类型定义中 12345678class GenericNumber&lt;T&gt; { zeroValue: T; add: (x: T, y: T) =&gt; T;}let myGenericNumber = new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue = 0;myGenericNumber.add = function(x, y) { return x + y; }; 泛型参数的默认类型在 TypeScript 2.3 以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用 1234567function createArray&lt;T = string&gt;(length: number, value: T): Array&lt;T&gt; { let result: T[] = []; for (let i = 0; i &lt; length; i++) { result[i] = value; } return result;}","link":"/post/ab6db3b5.html"},{"title":"koa路由接口","text":"1234567891011121314151617181920const router = require('koa-router')()//返回一个页面router.get('/', async (ctx, next) =&gt; { global.console.log('index11111'); await ctx.render('index', { //render返回一个页面 title: 'Hello Koa 2!' })})//直接返回数据的用body，json数据router.get('/json', async (ctx, next) =&gt; { ctx.body = { title: 'koa2 json' }})//在不同页面为了区分接口，我们可以在加个前缀/userrouter.prefix('/users')module.exports = router// app.js文件app.use(index.routes(), index.allowedMethods())","link":"/post/43948d34.html"},{"title":"vue的计算属性computed","text":"vue的计算属性用于简单运算，在模版中太多的逻辑会难以维护，例如:123&lt;div id=\"example\"&gt; {{ message.split('').reverse().join('') }}&lt;/div&gt; 这个地方逻辑是字符串反转，如果多次使用会造成不好维护的现象，而且逻辑代码写在模版里可读性并不是很好。 1234&lt;div id=\"example\"&gt; &lt;p&gt;Original message: \"{{ message }}\"&lt;/p&gt; &lt;p&gt;Computed reversed message: \"{{ reversedMessage }}\"&lt;/p&gt;&lt;/div&gt; 12345678910111213var vm = new Vue({ el: '#example', data: { message: 'Hello' }, computed: { // 计算属性的 getter reversedMessage: function () { // `this` 指向 vm 实例 return this.message.split('').reverse().join('') } }}) 有的人会说在methods里写个方法在模版里调用也是可以的，跟计算属性没什么区别，但我要说的是实现结果是一样的，但是计算属性是把值存储在缓存里，当值不发生改变的时候取得是缓存的值，而函数调用每次都会执行，性能优化并不是很好，所以极力推荐使用计算属性。 计算属性的setter12345678910111213141516// ...computed: { fullName: { // getter get: function () { return this.firstName + ' ' + this.lastName }, // setter set: function (newValue) { var names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length - 1] } }}// ... 现在再运行 vm.fullName = ‘John Doe’ 时，setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新。","link":"/post/7e77297b.html"},{"title":"没有在 v-if / v-if-else / v-else 中使用 key","text":"如果一组 v-if + v-else 的元素类型相同，最好使用 key (比如两个 &lt;div&gt; 元素)。 默认情况下，Vue 会尽可能高效的更新 DOM。这意味着其在相同类型的元素之间切换时，会修补已存在的元素，而不是将旧的元素移除然后在同一位置添加一个新元素。如果本不相同的元素被识别为相同，则会出现意料之外的结果。 123456789101112&lt;div v-if=\"error\" key=\"search-status\"&gt; 错误：{{ error }}&lt;/div&gt;&lt;div v-else key=\"search-results\"&gt; {{ results }}&lt;/div&gt;","link":"/post/d0d99cf1.html"},{"title":"nuxt2.0项目创建（最新）","text":"使用import需要babel编译写法如下 12345678//修改1打开package.json文件\"dev\": \"cross-env NODE_ENV=development nodemon server/index.js --watch server --exec babel-node\",\"start\": \"cross-env NODE_ENV=production node server/index.js --exec babel-node\",//修改2在根目录创建.babelrc{\"presets\": [\"es2015\"]}//安装yarn add babel-preset-es2015 项目中使用sass1$ yarn add sass-loader node-sass 辅助工具安装MongoDB http://www.runoob.com/mongodb/mongodb-window-install.html redis http://www.runoob.com/redis/redis-install.html 数据库可视化工具 https://robomongo.org/ 修改nuxt.config.js12345css: [ 'element-ui/lib/theme-chalk/reset.css', 'element-ui/lib/theme-chalk/index.css', // '~assets/css/main.css'],","link":"/post/cdd3de79.html"},{"title":"vue为组件样式设置作用域（局部）","text":"对于应用来说，顶级 App 组件和布局组件中的样式可以是全局的，但是其它所有组件都应该是有作用域的。scoped 特性可以使css局部作用域，不受外界影响，不止要使用 scoped 特性，使用唯一的 class 名可以帮你确保那些三方库的 CSS 不会运用在你自己的 HTML 上。 123456789101112131415&lt;template&gt; &lt;button class=\"button button-close\"&gt;X&lt;/button&gt;&lt;/template&gt;&lt;!-- 使用 `scoped` 特性 --&gt;&lt;style scoped&gt;.button { border: none; border-radius: 2px;}.button-close { background-color: red;}&lt;/style&gt;","link":"/post/d0e1e15a.html"},{"title":"vue中computed的作用以及用法","text":"在vue中computed是计算属性，主要作用是把数据存储到内存中，减少不必要的请求，还可以利用computed给子组件的data赋值。 参考地址：https://www.jianshu.com/p/ff708a773dc0 1234567891011121314151617181920212223242526272829303132333435363738394041// 父组件&lt;template&gt; &lt;div&gt; &lt;navbar :ctype=\"ctype\"&gt;&lt;/navbar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import navbar from '@/components/navbar' export default { components: {navbar}, data () { return{ ctype:1 } } }&lt;/script&gt;// 子组件&lt;template&gt; &lt;div&gt; &lt;div&gt;{{thistype}}&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { props:['ctype'], computed: { normalizedSize: function () { return this.ctype.trim().toLowerCase() } }, data(){ return{ thistype:this.ctype } }}&lt;/script&gt;","link":"/post/61a074cf.html"},{"title":"koa中间件","text":"12345678910111213function pv(ctx){ global.console.log(ctx.path);}module.exports=function(){ return async function(ctx,next){ pv(ctx); await next(); //next是继续执行下面的中间件，如果不写会直接跳出，不会继续执行 } }// app.js文件const pv = require('./middleware/koa-pv');app.use(pv())","link":"/post/ee74f09a.html"},{"title":"vue中this.$set的用法","text":"当vue的data里边声明或者已经赋值过的对象或者数组（数组里边的值是对象）时，向对象中添加新的属性，如果更新此属性的值，是不会更新视图的。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;template&gt;&lt;div id=\"app2\"&gt;&lt;p v-for=\"item in items\" :key=\"item.id\"&gt;{{item.message}}&lt;/p&gt;&lt;button class=\"btn\" @click=\"handClick()\"&gt;更改数据&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {data() {return {items: [{ message: \"one\", id: \"1\" },{ message: \"two\", id: \"2\" },{ message: \"three\", id: \"3\" }]};},mounted(){this.items[0]={message:\"测试\",id:\"4\"}; //此时对象的值更改了，但是视图没有更新this.$set(this.items,0,{message:\"测试\",id:\"4\"})； //$set可以触发更新视图console.log(this.items)},methods: {// 调用方法：Vue.set( target, key, value )// target：要更改的数据源(可以是对象或者数组)// key：要更改的具体数据// value ：重新赋的值handClick() {//Vue methods中的this 指向的是Vue的实例，这里可以直接在this中找到itemsthis.$set(this.items, 0, { message: \"更改one的值\", id: \"0\" });},}};&lt;/script&gt;&lt;style&gt;&lt;/style&gt;","link":"/post/cf9c7620.html"},{"title":"新建koa2项目","text":"1.npm install -g koa-generator 2.koa2 项目名称，如果需要ejs引擎koa2 -e 项目名称 3.cd 项目名称 4.npm install 5.npm install –update-binary 6.npm run dev 小知识点：对于start和test可以使用npm，对于dev和prd必须使用npm run来启动","link":"/post/abc93af2.html"},{"title":"nuxt写路由接口","text":"1234567891011121314//在server/interface/city.jsimport Router from 'koa-router';const router = new Router({ prefix:'/city' //给路由添加前缀})router.get('/list', async (ctx) =&gt; { ctx.body=['北京','天津']})export default router;//在server/index.jsimport cityInterface from './interface/city'app.use(cityInterface.routes()).use(cityInterface.allowedMethods()) //固定写法 测试一下curl http://localhost:3000/city/list 或者浏览器输入http://localhost:3000/city/list","link":"/post/b3ca1ede.html"},{"title":"nuxt服务端渲染","text":"1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div class=\"page\"&gt; page is search &lt;ul&gt; &lt;li v-for=\"(item,idx) in list\" :key=\"idx\"&gt;{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import axios from 'axios';export default { layout: 'search', data() { return { list: [] } }, async asyncData(){ let { status, data: {list}} = await axios.get('http://localhost:3000/city/list') if(status === 200){ return { list } } }}&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 使用asyncData就是服务端渲染，computed只是浏览器的渲染刷新会有闪烁","link":"/post/f6e7d62a.html"},{"title":"vue中路由在新的标签页打开","text":"123456let routeData = this.$router.resolve({ name: 'commercialPreview', query: {cylType: this.$route.query.cylType}, params: { id: this.id }})window.open(routeData.href, '_blank')","link":"/post/635b6b47.html"},{"title":"避免 v-if 和 v-for 用在一起","text":"永远不要把 v-if 和 v-for 同时用在同一个元素上。 一般我们在两种常见的情况下会倾向于这样做： 为了过滤一个列表中的项目 (比如 v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot; )。在这种情形下，请将 users 替换为一个计算属性 (比如 activeUsers)，让其返回过滤后的列表。 比如 v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;。这种情形下，请v-if 移动至容器元素上 (比如 ul, ol)。 12345678&lt;ul&gt; &lt;li v-for=\"user in activeUsers\" :key=\"user.id\" &gt; {{ user.name }} &lt;/li&gt;&lt;/ul&gt; 1234567computed: { activeUsers: function () { return this.users.filter(function (user) { return user.isActive }) }} 我们将会获得如下好处： 过滤后的列表只会在 users 数组发生相关变化时才被重新运算，过滤更高效。 使用 v-for=&quot;user in activeUsers&quot; 之后，我们在渲染的时候只遍历活跃用户，渲染更高效。 解耦渲染层的逻辑，可维护性 (对逻辑的更改和扩展) 更强。","link":"/post/5fcc2b62.html"},{"title":"vue使用.env文件配置全局环境变量","text":"关于文件名：必须以如下方式命名，不要乱起名，也无需专门手动控制加载哪个文件 .env 全局默认配置文件，不论什么环境都会加载合并 .env.development 开发环境下的配置文件 .env.production 生产环境下的配置文件 注意：属性名必须以VUE_APP_开头，比如VUE_APP_XXX 1234567// .envNODE_ENV=productionVUE_APP_API_URL=/apiVUE_APP_IMG_URL=/VUE_APP_ENV=productionVUE_APP_FAVICON=favicon.ico 12345678// .env.developmentNODE_ENV=developmentVUE_APP_API_URL=/apiVUE_APP_IMG_URL=/VUE_APP_FAVICON=favicon-test.ico 关于文件的加载： 根据启动命令vue会自动加载对应的环境，vue是根据文件名进行加载的，所以上面说“不要乱起名，也无需专门控制加载哪个文件” 比如执行npm run serve命令，会自动加载.env.development文件，打印process.env属性（全局属性，任何地方均可使用） 可见NODE_ENV被改为了development，覆盖掉了.env中的全局属性 .env中的全局属性NODE_ENV、VUE_APP_URL被覆盖， .env中的全局属性VUE_APP_PREVIEW、VUE_APP_DEFAULT_PARAM被保留 如果你想要在构建命令中使用开发环境变量，请在你的 package.json 脚本中加入： 1&quot;dev-build&quot;: &quot;vue-cli-service build --mode development&quot;,","link":"/post/4641e06a.html"},{"title":"vue组件中的.sync修饰符使用","text":"在vue的组件通信props中，一般情况下，数据都是单向的，子组件不会更改父组件的值，那么vue提供.sync作为双向传递的关键字，实现了父组件的变动会传递给子组件，而子组件的carts改变时，通过事件机制，修改父组件的cart。完成了子组件carts和父组件cart的双向映射。 12345678910111213141516// 父组件&lt;addicon :cart.sync=\"cart\"&gt;&lt;/addicon&gt;//子组件props: ['cart'],data: function () { return { carts: this.cart; }},methods:{ add:function(){ this.carts=10; this.$emit('update:cart',this.carts); }}","link":"/post/a43a7ab7.html"},{"title":"微信小程序组建通信","text":"子组件传递父组件需要用到triggerEvent方法，当子组件（自定义组件）点击button的时候调用triggerEvent方法传递一些数据，首先第一个属性为自定义名称（myevent）对应父组件（bind:myevent）名字是个标识必须相同，第二个参数就是要传递的数据，第三个参数是一些配置具体参考 https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/events.html。父组件bind:myevent=”onMyEvent”事件绑定，通过e.detail.count来获取数据。 123456789101112131415161718192021222324//父组件，引用component-tag-name&lt;component-tag-name bind:myevent=\"onMyEvent\" /&gt;//index.jsComponent({ onMyEvent(e) { e.detail.count // 自定义组件触发事件时提供的detail对象，结果为1 }})//子组件&lt;button bindtap=\"onTap\"&gt;点击这个按钮将触发“myevent”事件&lt;/button&gt;//index.jsComponent({ properties: {}, methods: { onTap() { const myEventDetail = {count:1} // detail对象，提供给事件监听函数 const myEventOption = {} // 触发事件的选项 this.triggerEvent('myevent', myEventDetail, myEventOption) } }})","link":"/post/2f44a81e.html"},{"title":"微信小程序rpx单位","text":"首先我们通常用的是px单位，那么我们知道px适用于pc端，那么如果px用到小程序或者移动端显示效果都不是很精确，所有我们小程序使用的是rpx单位，那么有什么区别吗？rpx单位支持自适应，也就是说无论多大尺寸的屏幕都会保持做原始的大小，会随着屏幕而改变，那px就不同了，他的大小是rpx的两倍，且不说在小程序上不自适应，反而会显得很大，不是我们想要的大小，我们需要手动的去除以2来进行换算。但有些情况我们也是会使用到px的，比如不需要自适应的东西，就可以使用px。","link":"/post/44e2a489.html"},{"title":"微信小程序自定义组件","text":"1.首先在根目录新建components目录，然后在components下创建组件 2.新建组件之后再需要引入的地方引用例如在pages下的classic里引用 12345678910//classic.json{ \"usingComponents\": { \"v-like\":\"/components/like/index\" //键名是可以自定义的，为组件的名字 }}//classic.wxml&lt;v-like /&gt;","link":"/post/43f56f31.html"}],"tags":[{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"typeScript","slug":"typeScript","link":"/tags/typeScript/"},{"name":"微信小程序","slug":"微信小程序","link":"/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"ant-design-vue踩过的坑","slug":"前端/ant-design-vue踩过的坑","link":"/categories/%E5%89%8D%E7%AB%AF/ant-design-vue%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"},{"name":"es6","slug":"前端/es6","link":"/categories/%E5%89%8D%E7%AB%AF/es6/"},{"name":"javascript","slug":"前端/javascript","link":"/categories/%E5%89%8D%E7%AB%AF/javascript/"},{"name":"react","slug":"前端/react","link":"/categories/%E5%89%8D%E7%AB%AF/react/"},{"name":"typeScript","slug":"前端/typeScript","link":"/categories/%E5%89%8D%E7%AB%AF/typeScript/"},{"name":"vue","slug":"前端/vue","link":"/categories/%E5%89%8D%E7%AB%AF/vue/"},{"name":"微信小程序","slug":"前端/微信小程序","link":"/categories/%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]}